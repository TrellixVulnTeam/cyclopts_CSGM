###################
###  WARNING!!! ###
###################
# This file has been autogenerated

# Cython imports
from cython.operator cimport dereference as deref
from cython.operator cimport preincrement as inc
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy
from cpython.version cimport PY_MAJOR_VERSION
from cpython.ref cimport PyTypeObject
from cpython.type cimport PyType_Ready
from cpython.object cimport Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE

# Python Imports
import collections

cimport numpy as np
import numpy as np
np.import_array()

cimport xdress_extra_types

# Cython imports for types
cimport numpy as np
cimport exchange_instance
from libcpp.vector cimport vector as cpp_vector
from cyclopts cimport cpp_exchange_instance

# imports for types
import exchange_instance
import numpy as np

dtypes = {}

if PY_MAJOR_VERSION >= 3:
    basestring = str

# Dirty ifdef, else, else preprocessor hack
# see http://comments.gmane.org/gmane.comp.python.cython.user/4080
cdef extern from *:
    cdef void emit_ifpy2k "#if PY_MAJOR_VERSION == 2 //" ()
    cdef void emit_ifpy3k "#if PY_MAJOR_VERSION == 3 //" ()
    cdef void emit_else "#else //" ()
    cdef void emit_endif "#endif //" ()

# int dtype
cdef MemoryKnight[int] mk_int = MemoryKnight[int]()
cdef MemoryKnight[PyXDInt_Type] mk_int_type = MemoryKnight[PyXDInt_Type]()

cdef object pyxd_int_getitem(void * data, void * arr):


    pyval = int((<int *> data)[0])
    return pyval

cdef int pyxd_int_setitem(object value, void * data, void * arr):
    cdef int * new_data

    if isinstance(value, int):

        new_data = mk_int.renew(data)
        new_data[0] = <int> value
        return 0
    else:
        return -1

cdef void pyxd_int_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef int * new_dest

    if src != NULL:
        if (sstride == sizeof(int) and dstride == sizeof(int)):
            new_dest = mk_int.renew(dest)
            new_dest[0] = deref(<int *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_int.renew(<void *> a)
                new_dest[0] = deref(<int *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(int) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(int) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_int_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef int * new_dest
    if src != NULL:
        new_dest = mk_int.renew(dest)
        new_dest[0] = (<int *> src)[0]
    if swap:
        m = sizeof(int) / 2
        a = <char *> dest
        b = a + (sizeof(int) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_int_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef int zero = int()
    #return ((<int *> data)[0] != zero)

cdef int pyxd_int_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<int *> d1) == deref(<int *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_Int_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_Int_ArrFuncs)
PyXD_Int_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_int_getitem)
PyXD_Int_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_int_setitem)
PyXD_Int_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_int_copyswapn)
PyXD_Int_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_int_copyswap)
PyXD_Int_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_int_nonzero)
PyXD_Int_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_int_compare)

cdef object pyxd_int_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDInt_Type * cval
    cdef object pyval
    cval = mk_int_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_int_type_dealloc(object self):
    cdef PyXDInt_Type * cself = <PyXDInt_Type *> self
    mk_int_type.deall(cself)
    return

cdef object pyxd_int_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_int_type_alloc(subtype, 0)

cdef void pyxd_int_type_free(void * self):
    return

cdef object pyxd_int_type_str(object self):
    cdef PyXDInt_Type * cself = <PyXDInt_Type *> self


    pyval = int((cself.obval))
    s = str(pyval)
    return s

cdef object pyxd_int_type_repr(object self):
    cdef PyXDInt_Type * cself = <PyXDInt_Type *> self


    pyval = int((cself.obval))
    s = repr(pyval)
    return s

cdef int pyxd_int_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDInt_Type * x
    #cdef PyXDInt_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDInt_Type *> a
    #y = <PyXDInt_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_int_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDInt_Type * x
    #cdef PyXDInt_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDInt_Type *> a
    #y = <PyXDInt_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_int_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_int_type_members[1]
pyxd_int_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_int_type_getset[1]
pyxd_int_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_int_is_ready
cdef type PyXD_Int = type("xd_int", ((<object> PyArray_API[10]),), {})
pyxd_int_is_ready = PyType_Ready(<object> PyXD_Int)
(<PyTypeObject *> PyXD_Int).tp_basicsize = sizeof(PyXDInt_Type)
(<PyTypeObject *> PyXD_Int).tp_itemsize = 0
(<PyTypeObject *> PyXD_Int).tp_doc = "Python scalar type for int"
(<PyTypeObject *> PyXD_Int).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_Int).tp_alloc = pyxd_int_type_alloc
(<PyTypeObject *> PyXD_Int).tp_dealloc = pyxd_int_type_dealloc
(<PyTypeObject *> PyXD_Int).tp_new = pyxd_int_type_new
(<PyTypeObject *> PyXD_Int).tp_free = pyxd_int_type_free
(<PyTypeObject *> PyXD_Int).tp_str = pyxd_int_type_str
(<PyTypeObject *> PyXD_Int).tp_repr = pyxd_int_type_repr
(<PyTypeObject *> PyXD_Int).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_Int).tp_hash = pyxd_int_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_Int).tp_compare = &pyxd_int_type_compare
emit_endif()
(<PyTypeObject *> PyXD_Int).tp_richcompare = pyxd_int_type_richcompare
(<PyTypeObject *> PyXD_Int).tp_members = pyxd_int_type_members
(<PyTypeObject *> PyXD_Int).tp_getset = pyxd_int_type_getset
pyxd_int_is_ready = PyType_Ready(<object> PyXD_Int)
Py_INCREF(PyXD_Int)
XDInt = PyXD_Int

cdef PyArray_Descr * c_xd_int_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_int_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_int_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_int_descr.typeobj = <PyTypeObject *> PyXD_Int # typeobj
c_xd_int_descr.kind = 'x'  # kind, for xdress
c_xd_int_descr.type = 'x'  # type
c_xd_int_descr.byteorder = '='  # byteorder
c_xd_int_descr.flags = 0    # flags
c_xd_int_descr.type_num = 0    # type_num, assigned at registration
c_xd_int_descr.elsize = sizeof(int)  # elsize, 
c_xd_int_descr.alignment = 8  # alignment
c_xd_int_descr.subarray = NULL  # subarray
c_xd_int_descr.fields = NULL  # fields
c_xd_int_descr.names = NULL
(<PyArray_Descr *> c_xd_int_descr).f = <PyArray_ArrFuncs *> &PyXD_Int_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_int_descr = <object> (<void *> c_xd_int_descr)
Py_INCREF(<object> xd_int_descr)
xd_int = xd_int_descr
cdef int xd_int_num = PyArray_RegisterDataType(c_xd_int_descr)
dtypes['int'] = xd_int
dtypes['xd_int'] = xd_int
dtypes[xd_int_num] = xd_int



# double dtype
cdef MemoryKnight[double] mk_double = MemoryKnight[double]()
cdef MemoryKnight[PyXDDouble_Type] mk_double_type = MemoryKnight[PyXDDouble_Type]()

cdef object pyxd_double_getitem(void * data, void * arr):


    pyval = float((<double *> data)[0])
    return pyval

cdef int pyxd_double_setitem(object value, void * data, void * arr):
    cdef double * new_data

    if isinstance(value, float) or isinstance(value, int):

        new_data = mk_double.renew(data)
        new_data[0] = <double> value
        return 0
    else:
        return -1

cdef void pyxd_double_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef double * new_dest

    if src != NULL:
        if (sstride == sizeof(double) and dstride == sizeof(double)):
            new_dest = mk_double.renew(dest)
            new_dest[0] = deref(<double *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_double.renew(<void *> a)
                new_dest[0] = deref(<double *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(double) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(double) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_double_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef double * new_dest
    if src != NULL:
        new_dest = mk_double.renew(dest)
        new_dest[0] = (<double *> src)[0]
    if swap:
        m = sizeof(double) / 2
        a = <char *> dest
        b = a + (sizeof(double) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_double_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef double zero = double()
    #return ((<double *> data)[0] != zero)

cdef int pyxd_double_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<double *> d1) == deref(<double *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_Double_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_Double_ArrFuncs)
PyXD_Double_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_double_getitem)
PyXD_Double_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_double_setitem)
PyXD_Double_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_double_copyswapn)
PyXD_Double_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_double_copyswap)
PyXD_Double_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_double_nonzero)
PyXD_Double_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_double_compare)

cdef object pyxd_double_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDDouble_Type * cval
    cdef object pyval
    cval = mk_double_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_double_type_dealloc(object self):
    cdef PyXDDouble_Type * cself = <PyXDDouble_Type *> self
    mk_double_type.deall(cself)
    return

cdef object pyxd_double_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_double_type_alloc(subtype, 0)

cdef void pyxd_double_type_free(void * self):
    return

cdef object pyxd_double_type_str(object self):
    cdef PyXDDouble_Type * cself = <PyXDDouble_Type *> self


    pyval = float((cself.obval))
    s = str(pyval)
    return s

cdef object pyxd_double_type_repr(object self):
    cdef PyXDDouble_Type * cself = <PyXDDouble_Type *> self


    pyval = float((cself.obval))
    s = repr(pyval)
    return s

cdef int pyxd_double_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDDouble_Type * x
    #cdef PyXDDouble_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDDouble_Type *> a
    #y = <PyXDDouble_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_double_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDDouble_Type * x
    #cdef PyXDDouble_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDDouble_Type *> a
    #y = <PyXDDouble_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_double_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_double_type_members[1]
pyxd_double_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_double_type_getset[1]
pyxd_double_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_double_is_ready
cdef type PyXD_Double = type("xd_double", ((<object> PyArray_API[10]),), {})
pyxd_double_is_ready = PyType_Ready(<object> PyXD_Double)
(<PyTypeObject *> PyXD_Double).tp_basicsize = sizeof(PyXDDouble_Type)
(<PyTypeObject *> PyXD_Double).tp_itemsize = 0
(<PyTypeObject *> PyXD_Double).tp_doc = "Python scalar type for double"
(<PyTypeObject *> PyXD_Double).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_Double).tp_alloc = pyxd_double_type_alloc
(<PyTypeObject *> PyXD_Double).tp_dealloc = pyxd_double_type_dealloc
(<PyTypeObject *> PyXD_Double).tp_new = pyxd_double_type_new
(<PyTypeObject *> PyXD_Double).tp_free = pyxd_double_type_free
(<PyTypeObject *> PyXD_Double).tp_str = pyxd_double_type_str
(<PyTypeObject *> PyXD_Double).tp_repr = pyxd_double_type_repr
(<PyTypeObject *> PyXD_Double).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_Double).tp_hash = pyxd_double_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_Double).tp_compare = &pyxd_double_type_compare
emit_endif()
(<PyTypeObject *> PyXD_Double).tp_richcompare = pyxd_double_type_richcompare
(<PyTypeObject *> PyXD_Double).tp_members = pyxd_double_type_members
(<PyTypeObject *> PyXD_Double).tp_getset = pyxd_double_type_getset
pyxd_double_is_ready = PyType_Ready(<object> PyXD_Double)
Py_INCREF(PyXD_Double)
XDDouble = PyXD_Double

cdef PyArray_Descr * c_xd_double_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_double_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_double_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_double_descr.typeobj = <PyTypeObject *> PyXD_Double # typeobj
c_xd_double_descr.kind = 'x'  # kind, for xdress
c_xd_double_descr.type = 'x'  # type
c_xd_double_descr.byteorder = '='  # byteorder
c_xd_double_descr.flags = 0    # flags
c_xd_double_descr.type_num = 0    # type_num, assigned at registration
c_xd_double_descr.elsize = sizeof(double)  # elsize, 
c_xd_double_descr.alignment = 8  # alignment
c_xd_double_descr.subarray = NULL  # subarray
c_xd_double_descr.fields = NULL  # fields
c_xd_double_descr.names = NULL
(<PyArray_Descr *> c_xd_double_descr).f = <PyArray_ArrFuncs *> &PyXD_Double_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_double_descr = <object> (<void *> c_xd_double_descr)
Py_INCREF(<object> xd_double_descr)
xd_double = xd_double_descr
cdef int xd_double_num = PyArray_RegisterDataType(c_xd_double_descr)
dtypes['double'] = xd_double
dtypes['xd_double'] = xd_double
dtypes[xd_double_num] = xd_double



# cpp_exchange_instance.ExGroup dtype
cdef MemoryKnight[cpp_exchange_instance.ExGroup] mk_exgroup = MemoryKnight[cpp_exchange_instance.ExGroup]()
cdef MemoryKnight[PyXDExGroup_Type] mk_exgroup_type = MemoryKnight[PyXDExGroup_Type]()

cdef object pyxd_exgroup_getitem(void * data, void * arr):
    cdef exchange_instance.ExGroup data_proxy
    data_proxy = exchange_instance.ExGroup()
    (<cpp_exchange_instance.ExGroup *> data_proxy._inst)[0] = (<cpp_exchange_instance.ExGroup *> data)[0]
    pyval = data_proxy
    return pyval

cdef int pyxd_exgroup_setitem(object value, void * data, void * arr):
    cdef cpp_exchange_instance.ExGroup * new_data
    cdef exchange_instance.ExGroup value_proxy
    if isinstance(value, exchange_instance.ExGroup):
        value_proxy = <exchange_instance.ExGroup> value
        new_data = mk_exgroup.renew(data)
        new_data[0] = (<cpp_exchange_instance.ExGroup *> value_proxy._inst)[0]
        return 0
    else:
        return -1

cdef void pyxd_exgroup_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExGroup * new_dest

    if src != NULL:
        if (sstride == sizeof(cpp_exchange_instance.ExGroup) and dstride == sizeof(cpp_exchange_instance.ExGroup)):
            new_dest = mk_exgroup.renew(dest)
            new_dest[0] = deref(<cpp_exchange_instance.ExGroup *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_exgroup.renew(<void *> a)
                new_dest[0] = deref(<cpp_exchange_instance.ExGroup *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(cpp_exchange_instance.ExGroup) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(cpp_exchange_instance.ExGroup) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_exgroup_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExGroup * new_dest
    if src != NULL:
        new_dest = mk_exgroup.renew(dest)
        new_dest[0] = (<cpp_exchange_instance.ExGroup *> src)[0]
    if swap:
        m = sizeof(cpp_exchange_instance.ExGroup) / 2
        a = <char *> dest
        b = a + (sizeof(cpp_exchange_instance.ExGroup) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_exgroup_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef cpp_exchange_instance.ExGroup zero = cpp_exchange_instance.ExGroup()
    #return ((<cpp_exchange_instance.ExGroup *> data)[0] != zero)

cdef int pyxd_exgroup_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<cpp_exchange_instance.ExGroup *> d1) == deref(<cpp_exchange_instance.ExGroup *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_ExGroup_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_ExGroup_ArrFuncs)
PyXD_ExGroup_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_exgroup_getitem)
PyXD_ExGroup_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_exgroup_setitem)
PyXD_ExGroup_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_exgroup_copyswapn)
PyXD_ExGroup_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_exgroup_copyswap)
PyXD_ExGroup_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_exgroup_nonzero)
PyXD_ExGroup_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_exgroup_compare)

cdef object pyxd_exgroup_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDExGroup_Type * cval
    cdef object pyval
    cval = mk_exgroup_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_exgroup_type_dealloc(object self):
    cdef PyXDExGroup_Type * cself = <PyXDExGroup_Type *> self
    mk_exgroup_type.deall(cself)
    return

cdef object pyxd_exgroup_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_exgroup_type_alloc(subtype, 0)

cdef void pyxd_exgroup_type_free(void * self):
    return

cdef object pyxd_exgroup_type_str(object self):
    cdef PyXDExGroup_Type * cself = <PyXDExGroup_Type *> self
    cdef exchange_instance.ExGroup val_proxy
    val_proxy = exchange_instance.ExGroup()
    (<cpp_exchange_instance.ExGroup *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = str(pyval)
    return s

cdef object pyxd_exgroup_type_repr(object self):
    cdef PyXDExGroup_Type * cself = <PyXDExGroup_Type *> self
    cdef exchange_instance.ExGroup val_proxy
    val_proxy = exchange_instance.ExGroup()
    (<cpp_exchange_instance.ExGroup *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = repr(pyval)
    return s

cdef int pyxd_exgroup_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExGroup_Type * x
    #cdef PyXDExGroup_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDExGroup_Type *> a
    #y = <PyXDExGroup_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_exgroup_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExGroup_Type * x
    #cdef PyXDExGroup_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDExGroup_Type *> a
    #y = <PyXDExGroup_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_exgroup_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_exgroup_type_members[1]
pyxd_exgroup_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_exgroup_type_getset[1]
pyxd_exgroup_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_exgroup_is_ready
cdef type PyXD_ExGroup = type("xd_exgroup", ((<object> PyArray_API[10]),), {})
pyxd_exgroup_is_ready = PyType_Ready(<object> PyXD_ExGroup)
(<PyTypeObject *> PyXD_ExGroup).tp_basicsize = sizeof(PyXDExGroup_Type)
(<PyTypeObject *> PyXD_ExGroup).tp_itemsize = 0
(<PyTypeObject *> PyXD_ExGroup).tp_doc = "Python scalar type for cpp_exchange_instance.ExGroup"
(<PyTypeObject *> PyXD_ExGroup).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_ExGroup).tp_alloc = pyxd_exgroup_type_alloc
(<PyTypeObject *> PyXD_ExGroup).tp_dealloc = pyxd_exgroup_type_dealloc
(<PyTypeObject *> PyXD_ExGroup).tp_new = pyxd_exgroup_type_new
(<PyTypeObject *> PyXD_ExGroup).tp_free = pyxd_exgroup_type_free
(<PyTypeObject *> PyXD_ExGroup).tp_str = pyxd_exgroup_type_str
(<PyTypeObject *> PyXD_ExGroup).tp_repr = pyxd_exgroup_type_repr
(<PyTypeObject *> PyXD_ExGroup).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_ExGroup).tp_hash = pyxd_exgroup_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_ExGroup).tp_compare = &pyxd_exgroup_type_compare
emit_endif()
(<PyTypeObject *> PyXD_ExGroup).tp_richcompare = pyxd_exgroup_type_richcompare
(<PyTypeObject *> PyXD_ExGroup).tp_members = pyxd_exgroup_type_members
(<PyTypeObject *> PyXD_ExGroup).tp_getset = pyxd_exgroup_type_getset
pyxd_exgroup_is_ready = PyType_Ready(<object> PyXD_ExGroup)
Py_INCREF(PyXD_ExGroup)
XDExGroup = PyXD_ExGroup

cdef PyArray_Descr * c_xd_exgroup_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_exgroup_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_exgroup_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_exgroup_descr.typeobj = <PyTypeObject *> PyXD_ExGroup # typeobj
c_xd_exgroup_descr.kind = 'x'  # kind, for xdress
c_xd_exgroup_descr.type = 'x'  # type
c_xd_exgroup_descr.byteorder = '='  # byteorder
c_xd_exgroup_descr.flags = 0    # flags
c_xd_exgroup_descr.type_num = 0    # type_num, assigned at registration
c_xd_exgroup_descr.elsize = sizeof(cpp_exchange_instance.ExGroup)  # elsize, 
c_xd_exgroup_descr.alignment = 8  # alignment
c_xd_exgroup_descr.subarray = NULL  # subarray
c_xd_exgroup_descr.fields = NULL  # fields
c_xd_exgroup_descr.names = NULL
(<PyArray_Descr *> c_xd_exgroup_descr).f = <PyArray_ArrFuncs *> &PyXD_ExGroup_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_exgroup_descr = <object> (<void *> c_xd_exgroup_descr)
Py_INCREF(<object> xd_exgroup_descr)
xd_exgroup = xd_exgroup_descr
cdef int xd_exgroup_num = PyArray_RegisterDataType(c_xd_exgroup_descr)
dtypes['exgroup'] = xd_exgroup
dtypes['xd_exgroup'] = xd_exgroup
dtypes[xd_exgroup_num] = xd_exgroup



# cpp_exchange_instance.ExNode dtype
cdef MemoryKnight[cpp_exchange_instance.ExNode] mk_exnode = MemoryKnight[cpp_exchange_instance.ExNode]()
cdef MemoryKnight[PyXDExNode_Type] mk_exnode_type = MemoryKnight[PyXDExNode_Type]()

cdef object pyxd_exnode_getitem(void * data, void * arr):
    cdef exchange_instance.ExNode data_proxy
    data_proxy = exchange_instance.ExNode()
    (<cpp_exchange_instance.ExNode *> data_proxy._inst)[0] = (<cpp_exchange_instance.ExNode *> data)[0]
    pyval = data_proxy
    return pyval

cdef int pyxd_exnode_setitem(object value, void * data, void * arr):
    cdef cpp_exchange_instance.ExNode * new_data
    cdef exchange_instance.ExNode value_proxy
    if isinstance(value, exchange_instance.ExNode):
        value_proxy = <exchange_instance.ExNode> value
        new_data = mk_exnode.renew(data)
        new_data[0] = (<cpp_exchange_instance.ExNode *> value_proxy._inst)[0]
        return 0
    else:
        return -1

cdef void pyxd_exnode_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExNode * new_dest

    if src != NULL:
        if (sstride == sizeof(cpp_exchange_instance.ExNode) and dstride == sizeof(cpp_exchange_instance.ExNode)):
            new_dest = mk_exnode.renew(dest)
            new_dest[0] = deref(<cpp_exchange_instance.ExNode *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_exnode.renew(<void *> a)
                new_dest[0] = deref(<cpp_exchange_instance.ExNode *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(cpp_exchange_instance.ExNode) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(cpp_exchange_instance.ExNode) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_exnode_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExNode * new_dest
    if src != NULL:
        new_dest = mk_exnode.renew(dest)
        new_dest[0] = (<cpp_exchange_instance.ExNode *> src)[0]
    if swap:
        m = sizeof(cpp_exchange_instance.ExNode) / 2
        a = <char *> dest
        b = a + (sizeof(cpp_exchange_instance.ExNode) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_exnode_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef cpp_exchange_instance.ExNode zero = cpp_exchange_instance.ExNode()
    #return ((<cpp_exchange_instance.ExNode *> data)[0] != zero)

cdef int pyxd_exnode_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<cpp_exchange_instance.ExNode *> d1) == deref(<cpp_exchange_instance.ExNode *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_ExNode_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_ExNode_ArrFuncs)
PyXD_ExNode_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_exnode_getitem)
PyXD_ExNode_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_exnode_setitem)
PyXD_ExNode_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_exnode_copyswapn)
PyXD_ExNode_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_exnode_copyswap)
PyXD_ExNode_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_exnode_nonzero)
PyXD_ExNode_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_exnode_compare)

cdef object pyxd_exnode_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDExNode_Type * cval
    cdef object pyval
    cval = mk_exnode_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_exnode_type_dealloc(object self):
    cdef PyXDExNode_Type * cself = <PyXDExNode_Type *> self
    mk_exnode_type.deall(cself)
    return

cdef object pyxd_exnode_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_exnode_type_alloc(subtype, 0)

cdef void pyxd_exnode_type_free(void * self):
    return

cdef object pyxd_exnode_type_str(object self):
    cdef PyXDExNode_Type * cself = <PyXDExNode_Type *> self
    cdef exchange_instance.ExNode val_proxy
    val_proxy = exchange_instance.ExNode()
    (<cpp_exchange_instance.ExNode *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = str(pyval)
    return s

cdef object pyxd_exnode_type_repr(object self):
    cdef PyXDExNode_Type * cself = <PyXDExNode_Type *> self
    cdef exchange_instance.ExNode val_proxy
    val_proxy = exchange_instance.ExNode()
    (<cpp_exchange_instance.ExNode *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = repr(pyval)
    return s

cdef int pyxd_exnode_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExNode_Type * x
    #cdef PyXDExNode_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDExNode_Type *> a
    #y = <PyXDExNode_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_exnode_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExNode_Type * x
    #cdef PyXDExNode_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDExNode_Type *> a
    #y = <PyXDExNode_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_exnode_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_exnode_type_members[1]
pyxd_exnode_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_exnode_type_getset[1]
pyxd_exnode_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_exnode_is_ready
cdef type PyXD_ExNode = type("xd_exnode", ((<object> PyArray_API[10]),), {})
pyxd_exnode_is_ready = PyType_Ready(<object> PyXD_ExNode)
(<PyTypeObject *> PyXD_ExNode).tp_basicsize = sizeof(PyXDExNode_Type)
(<PyTypeObject *> PyXD_ExNode).tp_itemsize = 0
(<PyTypeObject *> PyXD_ExNode).tp_doc = "Python scalar type for cpp_exchange_instance.ExNode"
(<PyTypeObject *> PyXD_ExNode).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_ExNode).tp_alloc = pyxd_exnode_type_alloc
(<PyTypeObject *> PyXD_ExNode).tp_dealloc = pyxd_exnode_type_dealloc
(<PyTypeObject *> PyXD_ExNode).tp_new = pyxd_exnode_type_new
(<PyTypeObject *> PyXD_ExNode).tp_free = pyxd_exnode_type_free
(<PyTypeObject *> PyXD_ExNode).tp_str = pyxd_exnode_type_str
(<PyTypeObject *> PyXD_ExNode).tp_repr = pyxd_exnode_type_repr
(<PyTypeObject *> PyXD_ExNode).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_ExNode).tp_hash = pyxd_exnode_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_ExNode).tp_compare = &pyxd_exnode_type_compare
emit_endif()
(<PyTypeObject *> PyXD_ExNode).tp_richcompare = pyxd_exnode_type_richcompare
(<PyTypeObject *> PyXD_ExNode).tp_members = pyxd_exnode_type_members
(<PyTypeObject *> PyXD_ExNode).tp_getset = pyxd_exnode_type_getset
pyxd_exnode_is_ready = PyType_Ready(<object> PyXD_ExNode)
Py_INCREF(PyXD_ExNode)
XDExNode = PyXD_ExNode

cdef PyArray_Descr * c_xd_exnode_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_exnode_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_exnode_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_exnode_descr.typeobj = <PyTypeObject *> PyXD_ExNode # typeobj
c_xd_exnode_descr.kind = 'x'  # kind, for xdress
c_xd_exnode_descr.type = 'x'  # type
c_xd_exnode_descr.byteorder = '='  # byteorder
c_xd_exnode_descr.flags = 0    # flags
c_xd_exnode_descr.type_num = 0    # type_num, assigned at registration
c_xd_exnode_descr.elsize = sizeof(cpp_exchange_instance.ExNode)  # elsize, 
c_xd_exnode_descr.alignment = 8  # alignment
c_xd_exnode_descr.subarray = NULL  # subarray
c_xd_exnode_descr.fields = NULL  # fields
c_xd_exnode_descr.names = NULL
(<PyArray_Descr *> c_xd_exnode_descr).f = <PyArray_ArrFuncs *> &PyXD_ExNode_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_exnode_descr = <object> (<void *> c_xd_exnode_descr)
Py_INCREF(<object> xd_exnode_descr)
xd_exnode = xd_exnode_descr
cdef int xd_exnode_num = PyArray_RegisterDataType(c_xd_exnode_descr)
dtypes['exnode'] = xd_exnode
dtypes['xd_exnode'] = xd_exnode
dtypes[xd_exnode_num] = xd_exnode



# cpp_exchange_instance.ExArc dtype
cdef MemoryKnight[cpp_exchange_instance.ExArc] mk_exarc = MemoryKnight[cpp_exchange_instance.ExArc]()
cdef MemoryKnight[PyXDExArc_Type] mk_exarc_type = MemoryKnight[PyXDExArc_Type]()

cdef object pyxd_exarc_getitem(void * data, void * arr):
    cdef exchange_instance.ExArc data_proxy
    data_proxy = exchange_instance.ExArc()
    (<cpp_exchange_instance.ExArc *> data_proxy._inst)[0] = (<cpp_exchange_instance.ExArc *> data)[0]
    pyval = data_proxy
    return pyval

cdef int pyxd_exarc_setitem(object value, void * data, void * arr):
    cdef cpp_exchange_instance.ExArc * new_data
    cdef exchange_instance.ExArc value_proxy
    if isinstance(value, exchange_instance.ExArc):
        value_proxy = <exchange_instance.ExArc> value
        new_data = mk_exarc.renew(data)
        new_data[0] = (<cpp_exchange_instance.ExArc *> value_proxy._inst)[0]
        return 0
    else:
        return -1

cdef void pyxd_exarc_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExArc * new_dest

    if src != NULL:
        if (sstride == sizeof(cpp_exchange_instance.ExArc) and dstride == sizeof(cpp_exchange_instance.ExArc)):
            new_dest = mk_exarc.renew(dest)
            new_dest[0] = deref(<cpp_exchange_instance.ExArc *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_exarc.renew(<void *> a)
                new_dest[0] = deref(<cpp_exchange_instance.ExArc *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(cpp_exchange_instance.ExArc) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(cpp_exchange_instance.ExArc) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_exarc_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_exchange_instance.ExArc * new_dest
    if src != NULL:
        new_dest = mk_exarc.renew(dest)
        new_dest[0] = (<cpp_exchange_instance.ExArc *> src)[0]
    if swap:
        m = sizeof(cpp_exchange_instance.ExArc) / 2
        a = <char *> dest
        b = a + (sizeof(cpp_exchange_instance.ExArc) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_exarc_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef cpp_exchange_instance.ExArc zero = cpp_exchange_instance.ExArc()
    #return ((<cpp_exchange_instance.ExArc *> data)[0] != zero)

cdef int pyxd_exarc_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<cpp_exchange_instance.ExArc *> d1) == deref(<cpp_exchange_instance.ExArc *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_ExArc_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_ExArc_ArrFuncs)
PyXD_ExArc_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_exarc_getitem)
PyXD_ExArc_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_exarc_setitem)
PyXD_ExArc_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_exarc_copyswapn)
PyXD_ExArc_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_exarc_copyswap)
PyXD_ExArc_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_exarc_nonzero)
PyXD_ExArc_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_exarc_compare)

cdef object pyxd_exarc_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDExArc_Type * cval
    cdef object pyval
    cval = mk_exarc_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_exarc_type_dealloc(object self):
    cdef PyXDExArc_Type * cself = <PyXDExArc_Type *> self
    mk_exarc_type.deall(cself)
    return

cdef object pyxd_exarc_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_exarc_type_alloc(subtype, 0)

cdef void pyxd_exarc_type_free(void * self):
    return

cdef object pyxd_exarc_type_str(object self):
    cdef PyXDExArc_Type * cself = <PyXDExArc_Type *> self
    cdef exchange_instance.ExArc val_proxy
    val_proxy = exchange_instance.ExArc()
    (<cpp_exchange_instance.ExArc *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = str(pyval)
    return s

cdef object pyxd_exarc_type_repr(object self):
    cdef PyXDExArc_Type * cself = <PyXDExArc_Type *> self
    cdef exchange_instance.ExArc val_proxy
    val_proxy = exchange_instance.ExArc()
    (<cpp_exchange_instance.ExArc *> val_proxy._inst)[0] = (cself.obval)
    pyval = val_proxy
    s = repr(pyval)
    return s

cdef int pyxd_exarc_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExArc_Type * x
    #cdef PyXDExArc_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDExArc_Type *> a
    #y = <PyXDExArc_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_exarc_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDExArc_Type * x
    #cdef PyXDExArc_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDExArc_Type *> a
    #y = <PyXDExArc_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_exarc_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_exarc_type_members[1]
pyxd_exarc_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_exarc_type_getset[1]
pyxd_exarc_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_exarc_is_ready
cdef type PyXD_ExArc = type("xd_exarc", ((<object> PyArray_API[10]),), {})
pyxd_exarc_is_ready = PyType_Ready(<object> PyXD_ExArc)
(<PyTypeObject *> PyXD_ExArc).tp_basicsize = sizeof(PyXDExArc_Type)
(<PyTypeObject *> PyXD_ExArc).tp_itemsize = 0
(<PyTypeObject *> PyXD_ExArc).tp_doc = "Python scalar type for cpp_exchange_instance.ExArc"
(<PyTypeObject *> PyXD_ExArc).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_ExArc).tp_alloc = pyxd_exarc_type_alloc
(<PyTypeObject *> PyXD_ExArc).tp_dealloc = pyxd_exarc_type_dealloc
(<PyTypeObject *> PyXD_ExArc).tp_new = pyxd_exarc_type_new
(<PyTypeObject *> PyXD_ExArc).tp_free = pyxd_exarc_type_free
(<PyTypeObject *> PyXD_ExArc).tp_str = pyxd_exarc_type_str
(<PyTypeObject *> PyXD_ExArc).tp_repr = pyxd_exarc_type_repr
(<PyTypeObject *> PyXD_ExArc).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_ExArc).tp_hash = pyxd_exarc_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_ExArc).tp_compare = &pyxd_exarc_type_compare
emit_endif()
(<PyTypeObject *> PyXD_ExArc).tp_richcompare = pyxd_exarc_type_richcompare
(<PyTypeObject *> PyXD_ExArc).tp_members = pyxd_exarc_type_members
(<PyTypeObject *> PyXD_ExArc).tp_getset = pyxd_exarc_type_getset
pyxd_exarc_is_ready = PyType_Ready(<object> PyXD_ExArc)
Py_INCREF(PyXD_ExArc)
XDExArc = PyXD_ExArc

cdef PyArray_Descr * c_xd_exarc_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_exarc_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_exarc_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_exarc_descr.typeobj = <PyTypeObject *> PyXD_ExArc # typeobj
c_xd_exarc_descr.kind = 'x'  # kind, for xdress
c_xd_exarc_descr.type = 'x'  # type
c_xd_exarc_descr.byteorder = '='  # byteorder
c_xd_exarc_descr.flags = 0    # flags
c_xd_exarc_descr.type_num = 0    # type_num, assigned at registration
c_xd_exarc_descr.elsize = sizeof(cpp_exchange_instance.ExArc)  # elsize, 
c_xd_exarc_descr.alignment = 8  # alignment
c_xd_exarc_descr.subarray = NULL  # subarray
c_xd_exarc_descr.fields = NULL  # fields
c_xd_exarc_descr.names = NULL
(<PyArray_Descr *> c_xd_exarc_descr).f = <PyArray_ArrFuncs *> &PyXD_ExArc_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_exarc_descr = <object> (<void *> c_xd_exarc_descr)
Py_INCREF(<object> xd_exarc_descr)
xd_exarc = xd_exarc_descr
cdef int xd_exarc_num = PyArray_RegisterDataType(c_xd_exarc_descr)
dtypes['exarc'] = xd_exarc
dtypes['xd_exarc'] = xd_exarc
dtypes[xd_exarc_num] = xd_exarc



# cpp_vector[int] dtype
cdef MemoryKnight[cpp_vector[int]] mk_vector_int = MemoryKnight[cpp_vector[int]]()
cdef MemoryKnight[PyXDVectorInt_Type] mk_vector_int_type = MemoryKnight[PyXDVectorInt_Type]()

cdef object pyxd_vector_int_getitem(void * data, void * arr):
    cdef np.ndarray data_proxy
    cdef np.npy_intp data_proxy_shape[1]
    data_proxy_shape[0] = <np.npy_intp> (<cpp_vector[int] *> data)[0].size()
    data_proxy = np.PyArray_SimpleNewFromData(1, data_proxy_shape, np.NPY_INT32, &(<cpp_vector[int] *> data)[0][0])
    pyval = data_proxy
    return pyval

cdef int pyxd_vector_int_setitem(object value, void * data, void * arr):
    cdef cpp_vector[int] * new_data
    cdef cpp_vector[int] value_proxy
    cdef int ivalue
    cdef int value_size
    cdef int * value_data
    if isinstance(value, list) or isinstance(value, tuple) or isinstance(value, np.ndarray):
        # value is a ('vector', 'int32', 0)
        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == xd_vector_int.num:
            value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[int](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = value_data[ivalue]
        else:
            value_proxy = cpp_vector[int](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = <int> value[ivalue]
        new_data = mk_vector_int.renew(data)
        new_data[0] = value_proxy
        return 0
    else:
        return -1

cdef void pyxd_vector_int_copyswapn(void * dest, np.npy_intp dstride, void * src, np.npy_intp sstride, np.npy_intp n, int swap, void * arr):
    cdef np.npy_intp i
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_vector[int] * new_dest

    if src != NULL:
        if (sstride == sizeof(cpp_vector[int]) and dstride == sizeof(cpp_vector[int])):
            new_dest = mk_vector_int.renew(dest)
            new_dest[0] = deref(<cpp_vector[int] *> src)
        else:
            a = <char *> dest
            b = <char *> src
            for i in range(n):
                new_dest = mk_vector_int.renew(<void *> a)
                new_dest[0] = deref(<cpp_vector[int] *> b)
                a += dstride
                b += sstride
    if swap: 
        m = sizeof(cpp_vector[int]) / 2
        a = <char *> dest
        for i in range(n, 0, -1):
            b = a + (sizeof(cpp_vector[int]) - 1);
            for j in range(m):
                c = a[0]
                a[0] = b[0]
                a += 1
                b[0] = c
                b -= 1
            a += dstride - m

cdef void pyxd_vector_int_copyswap(void * dest, void * src, int swap, void * arr):
    cdef char * a 
    cdef char * b 
    cdef char c = 0
    cdef int j
    cdef int m
    cdef cpp_vector[int] * new_dest
    if src != NULL:
        new_dest = mk_vector_int.renew(dest)
        new_dest[0] = (<cpp_vector[int] *> src)[0]
    if swap:
        m = sizeof(cpp_vector[int]) / 2
        a = <char *> dest
        b = a + (sizeof(cpp_vector[int]) - 1);
        for j in range(m):
            c = a[0]
            a[0] = b[0]
            a += 1
            b[0] = c
            b -= 1

cdef np.npy_bool pyxd_vector_int_nonzero(void * data, void * arr):
    return (data != NULL)
    # FIXME comparisons not defined for arbitrary types
    #cdef cpp_vector[int] zero = cpp_vector[int]()
    #return ((<cpp_vector[int] *> data)[0] != zero)

cdef int pyxd_vector_int_compare(const void * d1, const void * d2, void * arr):
    return (d1 == d2) - 1
    # FIXME comparisons not defined for arbitrary types
    #if deref(<cpp_vector[int] *> d1) == deref(<cpp_vector[int] *> d2):
    #    return 0
    #else:
    #    return -1

cdef PyArray_ArrFuncs PyXD_VectorInt_ArrFuncs 
PyArray_InitArrFuncs(&PyXD_VectorInt_ArrFuncs)
PyXD_VectorInt_ArrFuncs.getitem = <PyArray_GetItemFunc *> (&pyxd_vector_int_getitem)
PyXD_VectorInt_ArrFuncs.setitem = <PyArray_SetItemFunc *> (&pyxd_vector_int_setitem)
PyXD_VectorInt_ArrFuncs.copyswapn = <PyArray_CopySwapNFunc *> (&pyxd_vector_int_copyswapn)
PyXD_VectorInt_ArrFuncs.copyswap = <PyArray_CopySwapFunc *> (&pyxd_vector_int_copyswap)
PyXD_VectorInt_ArrFuncs.nonzero = <PyArray_NonzeroFunc *> (&pyxd_vector_int_nonzero)
PyXD_VectorInt_ArrFuncs.compare = <PyArray_CompareFunc *> (&pyxd_vector_int_compare)

cdef object pyxd_vector_int_type_alloc(PyTypeObject * self, Py_ssize_t nitems):
    cdef PyXDVectorInt_Type * cval
    cdef object pyval
    cval = mk_vector_int_type.defnew()
    cval.ob_typ = self
    pyval = <object> cval
    return pyval

cdef void pyxd_vector_int_type_dealloc(object self):
    cdef PyXDVectorInt_Type * cself = <PyXDVectorInt_Type *> self
    mk_vector_int_type.deall(cself)
    return

cdef object pyxd_vector_int_type_new(PyTypeObject * subtype, object args, object kwds):
    return pyxd_vector_int_type_alloc(subtype, 0)

cdef void pyxd_vector_int_type_free(void * self):
    return

cdef object pyxd_vector_int_type_str(object self):
    cdef PyXDVectorInt_Type * cself = <PyXDVectorInt_Type *> self
    cdef np.ndarray val_proxy
    cdef np.npy_intp val_proxy_shape[1]
    val_proxy_shape[0] = <np.npy_intp> (cself.obval).size()
    val_proxy = np.PyArray_SimpleNewFromData(1, val_proxy_shape, np.NPY_INT32, &(cself.obval)[0])
    pyval = val_proxy
    s = str(pyval)
    return s

cdef object pyxd_vector_int_type_repr(object self):
    cdef PyXDVectorInt_Type * cself = <PyXDVectorInt_Type *> self
    cdef np.ndarray val_proxy
    cdef np.npy_intp val_proxy_shape[1]
    val_proxy_shape[0] = <np.npy_intp> (cself.obval).size()
    val_proxy = np.PyArray_SimpleNewFromData(1, val_proxy_shape, np.NPY_INT32, &(cself.obval)[0])
    pyval = val_proxy
    s = repr(pyval)
    return s

cdef int pyxd_vector_int_type_compare(object a, object b):
    return (a is b) - 1
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDVectorInt_Type * x
    #cdef PyXDVectorInt_Type * y
    #if type(a) is not type(b):
    #    raise NotImplementedError
    #x = <PyXDVectorInt_Type *> a
    #y = <PyXDVectorInt_Type *> b
    #if (x.obval == y.obval):
    #    return 0
    #elif (x.obval < y.obval):
    #    return -1
    #elif (x.obval > y.obval):
    #    return 1
    #else:
    #    raise NotImplementedError

cdef object pyxd_vector_int_type_richcompare(object a, object b, int op):
    if op == Py_EQ:
        return (a is b)
    elif op == Py_NE:
        return (a is not b)
    else:
        return NotImplemented
    # FIXME comparisons not defined for arbitrary types
    #cdef PyXDVectorInt_Type * x
    #cdef PyXDVectorInt_Type * y
    #if type(a) is not type(b):
    #    return NotImplemented
    #x = <PyXDVectorInt_Type *> a
    #y = <PyXDVectorInt_Type *> b
    #if op == Py_LT:
    #    return (x.obval < y.obval)
    #elif op == Py_LE:
    #    return (x.obval <= y.obval)
    #elif op == Py_EQ:
    #    return (x.obval == y.obval)
    #elif op == Py_NE:
    #    return (x.obval != y.obval)
    #elif op == Py_GT:
    #    return (x.obval > y.obval)
    #elif op == Py_GE:
    #    return (x.obval >= y.obval)
    #else:
    #    return NotImplemented    

cdef long pyxd_vector_int_type_hash(object self):
    return id(self)

cdef PyMemberDef pyxd_vector_int_type_members[1]
pyxd_vector_int_type_members[0] = PyMemberDef(NULL, 0, 0, 0, NULL)

cdef PyGetSetDef pyxd_vector_int_type_getset[1]
pyxd_vector_int_type_getset[0] = PyGetSetDef(NULL)

cdef bint pyxd_vector_int_is_ready
cdef type PyXD_VectorInt = type("xd_vector_int", ((<object> PyArray_API[10]),), {})
pyxd_vector_int_is_ready = PyType_Ready(<object> PyXD_VectorInt)
(<PyTypeObject *> PyXD_VectorInt).tp_basicsize = sizeof(PyXDVectorInt_Type)
(<PyTypeObject *> PyXD_VectorInt).tp_itemsize = 0
(<PyTypeObject *> PyXD_VectorInt).tp_doc = "Python scalar type for cpp_vector[int]"
(<PyTypeObject *> PyXD_VectorInt).tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HEAPTYPE
(<PyTypeObject *> PyXD_VectorInt).tp_alloc = pyxd_vector_int_type_alloc
(<PyTypeObject *> PyXD_VectorInt).tp_dealloc = pyxd_vector_int_type_dealloc
(<PyTypeObject *> PyXD_VectorInt).tp_new = pyxd_vector_int_type_new
(<PyTypeObject *> PyXD_VectorInt).tp_free = pyxd_vector_int_type_free
(<PyTypeObject *> PyXD_VectorInt).tp_str = pyxd_vector_int_type_str
(<PyTypeObject *> PyXD_VectorInt).tp_repr = pyxd_vector_int_type_repr
(<PyTypeObject *> PyXD_VectorInt).tp_base = (<PyTypeObject *> PyArray_API[10])  # PyGenericArrType_Type
(<PyTypeObject *> PyXD_VectorInt).tp_hash = pyxd_vector_int_type_hash
emit_ifpy2k()
(<PyTypeObject *> PyXD_VectorInt).tp_compare = &pyxd_vector_int_type_compare
emit_endif()
(<PyTypeObject *> PyXD_VectorInt).tp_richcompare = pyxd_vector_int_type_richcompare
(<PyTypeObject *> PyXD_VectorInt).tp_members = pyxd_vector_int_type_members
(<PyTypeObject *> PyXD_VectorInt).tp_getset = pyxd_vector_int_type_getset
pyxd_vector_int_is_ready = PyType_Ready(<object> PyXD_VectorInt)
Py_INCREF(PyXD_VectorInt)
XDVectorInt = PyXD_VectorInt

cdef PyArray_Descr * c_xd_vector_int_descr = <PyArray_Descr *> malloc(sizeof(PyArray_Descr))
(<PyObject *> c_xd_vector_int_descr).ob_refcnt = 0 # ob_refcnt
(<PyObject *> c_xd_vector_int_descr).ob_type = <PyTypeObject *> PyArray_API[3]
c_xd_vector_int_descr.typeobj = <PyTypeObject *> PyXD_VectorInt # typeobj
c_xd_vector_int_descr.kind = 'x'  # kind, for xdress
c_xd_vector_int_descr.type = 'x'  # type
c_xd_vector_int_descr.byteorder = '='  # byteorder
c_xd_vector_int_descr.flags = 0    # flags
c_xd_vector_int_descr.type_num = 0    # type_num, assigned at registration
c_xd_vector_int_descr.elsize = sizeof(cpp_vector[int])  # elsize, 
c_xd_vector_int_descr.alignment = 8  # alignment
c_xd_vector_int_descr.subarray = NULL  # subarray
c_xd_vector_int_descr.fields = NULL  # fields
c_xd_vector_int_descr.names = NULL
(<PyArray_Descr *> c_xd_vector_int_descr).f = <PyArray_ArrFuncs *> &PyXD_VectorInt_ArrFuncs  # f == PyArray_ArrFuncs

cdef object xd_vector_int_descr = <object> (<void *> c_xd_vector_int_descr)
Py_INCREF(<object> xd_vector_int_descr)
xd_vector_int = xd_vector_int_descr
cdef int xd_vector_int_num = PyArray_RegisterDataType(c_xd_vector_int_descr)
dtypes['vector_int'] = xd_vector_int
dtypes['xd_vector_int'] = xd_vector_int
dtypes[xd_vector_int_num] = xd_vector_int




###################
###  WARNING!!! ###
###################
# This file has been autogenerated

# Cython imports
from cython.operator cimport dereference as deref
from cython.operator cimport preincrement as inc
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy
from libcpp.string cimport string as std_string
from libcpp.utility cimport pair
from libcpp.map cimport map as cpp_map
from libcpp.set cimport set as cpp_set
from libcpp cimport bool as cpp_bool
from libcpp.vector cimport vector as cpp_vector
from cpython.version cimport PY_MAJOR_VERSION

# Python Imports
import collections

cimport numpy as np
import numpy as np

np.import_array()

cimport xdress_extra_types

# Cython Imports For Types
from libcpp.map cimport map as cpp_map
cimport exchange_instance
cimport dtypes
from libcpp cimport bool as cpp_bool
from cyclopts cimport cpp_exchange_instance
from libcpp.vector cimport vector as cpp_vector
cimport numpy as np

# Imports For Types
import exchange_instance
import numpy as np
import collections
import dtypes

if PY_MAJOR_VERSION >= 3:
    basestring = str

# Dirty ifdef, else, else preprocessor hack
# see http://comments.gmane.org/gmane.comp.python.cython.user/4080
cdef extern from *:
    cdef void emit_ifpy2k "#if PY_MAJOR_VERSION == 2 //" ()
    cdef void emit_ifpy3k "#if PY_MAJOR_VERSION == 3 //" ()
    cdef void emit_else "#else //" ()
    cdef void emit_endif "#endif //" ()

# int vector


# double vector


# cpp_exchange_instance.ExGroup vector


# cpp_exchange_instance.ExNode vector


# cpp_exchange_instance.ExArc vector


# cpp_vector[int] vector


# Map(Int, Double)
cdef class _MapIterIntDouble(object):
    cdef void init(self, cpp_map[int, double] * map_ptr):
        cdef cpp_map[int, double].iterator * itn = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, double].iterator * ite = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, double].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, double] item
        cdef cpp_map[int, double] * map_ptr



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntDouble):
            self.map_ptr = (<_MapIntDouble> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, double]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map.items():


                item = pair[int, double](<int> key, <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map:


                item = pair[int, double](<int> key, <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntDouble mi = _MapIterIntDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef double v


        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return float(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, double] item


        item = pair[int, double](<int> key, <double> value)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntDouble(_MapIntDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Int)
cdef class _MapIterIntInt(object):
    cdef void init(self, cpp_map[int, int] * map_ptr):
        cdef cpp_map[int, int].iterator * itn = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, int].iterator * ite = <cpp_map[int, int].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, int].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, int].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, int] item
        cdef cpp_map[int, int] * map_ptr



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntInt):
            self.map_ptr = (<_MapIntInt> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, int]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map.items():


                item = pair[int, int](<int> key, <int> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, int]()
            for key, value in new_map:


                item = pair[int, int](<int> key, <int> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, int]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntInt mi = _MapIterIntInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef int v


        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return int(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, int] item


        item = pair[int, int](<int> key, <int> value)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntInt(_MapIntInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, Bool)
cdef class _MapIterIntBool(object):
    cdef void init(self, cpp_map[int, cpp_bool] * map_ptr):
        cdef cpp_map[int, cpp_bool].iterator * itn = <cpp_map[int, cpp_bool].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_bool].iterator * ite = <cpp_map[int, cpp_bool].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_bool].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_bool].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntBool:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_bool] item
        cdef cpp_map[int, cpp_bool] * map_ptr



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntBool):
            self.map_ptr = (<_MapIntBool> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, cpp_bool]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_bool]()
            for key, value in new_map.items():


                item = pair[int, cpp_bool](<int> key, <bint> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_bool]()
            for key, value in new_map:


                item = pair[int, cpp_bool](<int> key, <bint> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_bool]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntBool mi = _MapIterIntBool()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_bool v


        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return bool(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, cpp_bool] item


        item = pair[int, cpp_bool](<int> key, <bint> value)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntBool(_MapIntBool, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, boolean>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, VectorInt)
cdef class _MapIterIntVectorInt(object):
    cdef void init(self, cpp_map[int, cpp_vector[int]] * map_ptr):
        cdef cpp_map[int, cpp_vector[int]].iterator * itn = <cpp_map[int, cpp_vector[int]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_vector[int]].iterator * ite = <cpp_map[int, cpp_vector[int]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_vector[int]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_vector[int]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntVectorInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_vector[int]] item
        cdef cpp_map[int, cpp_vector[int]] * map_ptr

        cdef cpp_vector[int] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef int * value_data

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntVectorInt):
            self.map_ptr = (<_MapIntVectorInt> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, cpp_vector[int]]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_vector[int]]()
            for key, value in new_map.items():

                # value is a ('vector', 'int32', 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
                    value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[int](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[int](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <int> value[ivalue]
                item = pair[int, cpp_vector[int]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_vector[int]]()
            for key, value in new_map:

                # value is a ('vector', 'int32', 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
                    value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[int](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[int](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <int> value[ivalue]
                item = pair[int, cpp_vector[int]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_vector[int]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntVectorInt mi = _MapIterIntVectorInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_vector[int] v

        cdef np.ndarray v_proxy
        cdef np.npy_intp v_proxy_shape[1]
        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy_shape[0] = <np.npy_intp> deref(self.map_ptr)[k].size()
            v_proxy = np.PyArray_SimpleNewFromData(1, v_proxy_shape, np.NPY_INT32, &deref(self.map_ptr)[k][0])
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef cpp_vector[int] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef int * value_data
        cdef pair[int, cpp_vector[int]] item

        # value is a ('vector', 'int32', 0)
        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
            value_data = <int *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[int](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = value_data[ivalue]
        else:
            value_proxy = cpp_vector[int](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = <int> value[ivalue]
        item = pair[int, cpp_vector[int]](<int> key, value_proxy)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntVectorInt(_MapIntVectorInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, vector [ndarray] of integer>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, VectorDouble)
cdef class _MapIterIntVectorDouble(object):
    cdef void init(self, cpp_map[int, cpp_vector[double]] * map_ptr):
        cdef cpp_map[int, cpp_vector[double]].iterator * itn = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_vector[double]].iterator * ite = <cpp_map[int, cpp_vector[double]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_vector[double]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_vector[double]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntVectorDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_vector[double]] item
        cdef cpp_map[int, cpp_vector[double]] * map_ptr

        cdef cpp_vector[double] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef double * value_data

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntVectorDouble):
            self.map_ptr = (<_MapIntVectorDouble> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map.items():

                # value is a ('vector', 'float64', 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <double> value[ivalue]
                item = pair[int, cpp_vector[double]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()
            for key, value in new_map:

                # value is a ('vector', 'float64', 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
                    value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[double](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <double> value[ivalue]
                item = pair[int, cpp_vector[double]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_vector[double]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntVectorDouble mi = _MapIterIntVectorDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_vector[double] v

        cdef np.ndarray v_proxy
        cdef np.npy_intp v_proxy_shape[1]
        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy_shape[0] = <np.npy_intp> deref(self.map_ptr)[k].size()
            v_proxy = np.PyArray_SimpleNewFromData(1, v_proxy_shape, np.NPY_FLOAT64, &deref(self.map_ptr)[k][0])
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef cpp_vector[double] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef double * value_data
        cdef pair[int, cpp_vector[double]] item

        # value is a ('vector', 'float64', 0)
        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == np.NPY_FLOAT64:
            value_data = <double *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[double](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = value_data[ivalue]
        else:
            value_proxy = cpp_vector[double](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = <double> value[ivalue]
        item = pair[int, cpp_vector[double]](<int> key, value_proxy)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntVectorDouble(_MapIntVectorDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, vector [ndarray] of double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, VectorVectorInt)
cdef class _MapIterIntVectorVectorInt(object):
    cdef void init(self, cpp_map[int, cpp_vector[cpp_vector[int]]] * map_ptr):
        cdef cpp_map[int, cpp_vector[cpp_vector[int]]].iterator * itn = <cpp_map[int, cpp_vector[cpp_vector[int]]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_vector[cpp_vector[int]]].iterator * ite = <cpp_map[int, cpp_vector[cpp_vector[int]]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_vector[cpp_vector[int]]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_vector[cpp_vector[int]]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntVectorVectorInt:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_vector[cpp_vector[int]]] item
        cdef cpp_map[int, cpp_vector[cpp_vector[int]]] * map_ptr

        cdef cpp_vector[cpp_vector[int]] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef cpp_vector[int] * value_data

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntVectorVectorInt):
            self.map_ptr = (<_MapIntVectorVectorInt> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, cpp_vector[cpp_vector[int]]]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_vector[cpp_vector[int]]]()
            for key, value in new_map.items():

                # value is a ('vector', ('vector', 'int32', 0), 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
                    value_data = <cpp_vector[int] *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <cpp_vector[int]> value[ivalue]
                item = pair[int, cpp_vector[cpp_vector[int]]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_vector[cpp_vector[int]]]()
            for key, value in new_map:

                # value is a ('vector', ('vector', 'int32', 0), 0)
                value_size = len(value)
                if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
                    value_data = <cpp_vector[int] *> np.PyArray_DATA(<np.ndarray> value)
                    value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = value_data[ivalue]
                else:
                    value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
                    for ivalue in range(value_size):
                        value_proxy[ivalue] = <cpp_vector[int]> value[ivalue]
                item = pair[int, cpp_vector[cpp_vector[int]]](<int> key, value_proxy)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_vector[cpp_vector[int]]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntVectorVectorInt mi = _MapIterIntVectorVectorInt()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_vector[cpp_vector[int]] v

        cdef np.ndarray v_proxy
        cdef np.npy_intp v_proxy_shape[1]
        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy_shape[0] = <np.npy_intp> deref(self.map_ptr)[k].size()
            v_proxy = np.PyArray_SimpleNewFromData(1, v_proxy_shape, dtypes.xd_vector_int.num, &deref(self.map_ptr)[k][0])
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef cpp_vector[cpp_vector[int]] value_proxy
        cdef int ivalue
        cdef int value_size
        cdef cpp_vector[int] * value_data
        cdef pair[int, cpp_vector[cpp_vector[int]]] item

        # value is a ('vector', ('vector', 'int32', 0), 0)
        value_size = len(value)
        if isinstance(value, np.ndarray) and (<np.ndarray> value).descr.type_num == dtypes.xd_vector_int.num:
            value_data = <cpp_vector[int] *> np.PyArray_DATA(<np.ndarray> value)
            value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = value_data[ivalue]
        else:
            value_proxy = cpp_vector[cpp_vector[int]](<size_t> value_size)
            for ivalue in range(value_size):
                value_proxy[ivalue] = <cpp_vector[int]> value[ivalue]
        item = pair[int, cpp_vector[cpp_vector[int]]](<int> key, value_proxy)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntVectorVectorInt(_MapIntVectorVectorInt, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, vector [ndarray] of ('vector', 'int32', 0)>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Map(Int, MapIntVectorDouble)
cdef class _MapIterIntMapIntVectorDouble(object):
    cdef void init(self, cpp_map[int, cpp_map[int, cpp_vector[double]]] * map_ptr):
        cdef cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator * itn = <cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator * ite = <cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, cpp_map[int, cpp_vector[double]]].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntMapIntVectorDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, cpp_map[int, cpp_vector[double]]] item
        cdef cpp_map[int, cpp_map[int, cpp_vector[double]]] * map_ptr

        cdef _MapIntVectorDouble value_proxy

        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntMapIntVectorDouble):
            self.map_ptr = (<_MapIntMapIntVectorDouble> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, cpp_map[int, cpp_vector[double]]]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, cpp_map[int, cpp_vector[double]]]()
            for key, value in new_map.items():

                value_proxy = MapIntVectorDouble(value, not isinstance(value, _MapIntVectorDouble))
                item = pair[int, cpp_map[int, cpp_vector[double]]](<int> key, value_proxy.map_ptr[0])
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, cpp_map[int, cpp_vector[double]]]()
            for key, value in new_map:

                value_proxy = MapIntVectorDouble(value, not isinstance(value, _MapIntVectorDouble))
                item = pair[int, cpp_map[int, cpp_vector[double]]](<int> key, value_proxy.map_ptr[0])
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, cpp_map[int, cpp_vector[double]]]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntMapIntVectorDouble mi = _MapIterIntMapIntVectorDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef cpp_map[int, cpp_vector[double]] v

        cdef _MapIntVectorDouble v_proxy
        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]
            v_proxy = MapIntVectorDouble(False, False)
            v_proxy.map_ptr = &deref(self.map_ptr)[k]
            return v_proxy
        else:
            raise KeyError

    def __setitem__(self, key, value):

        cdef _MapIntVectorDouble value_proxy
        cdef pair[int, cpp_map[int, cpp_vector[double]]] item

        value_proxy = MapIntVectorDouble(value, not isinstance(value, _MapIntVectorDouble))
        item = pair[int, cpp_map[int, cpp_vector[double]]](<int> key, value_proxy.map_ptr[0])
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntMapIntVectorDouble(_MapIntMapIntVectorDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, map of (integer, ('vector', 'float64', 0)) items>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



# Pair(Int, Int)
cdef class _PairIntInt:
    def __cinit__(self, first_val = None, second_val = None, bint free_pair=True):


        cdef pair[int, int] * pair_ptr

        if first_val is not None and second_val is not None:


            self.pair_ptr = new pair[int, int](<int> first_val, <int> second_val)
        elif first_val is not None or second_val is not None:
            raise TypeError("Constructor requires either both first and second defined or neither.")
        else:
            self.pair_ptr = new pair[int, int]()

        # Store free_pair
        self._free_pair = free_pair

    # c++-like members
    property first:
        def __get__(self):


            return int(self.pair_ptr[0].first)
        def __set__(self, first_val):


            self.pair_ptr[0].first = <int> first_val

    property second:
        def __get__(self):


            return int(self.pair_ptr[0].second)
        def __set__(self, second_val):


            self.pair_ptr[0].second = <int> second_val

    def __copy__(self):
        return _PairIntInt(self.first, self.second)

    def __dealloc__(self):
        if self._free_pair and self.pair_ptr is not NULL:
            del self.pair_ptr

    def __getitem__(self, i):
        if i == 0:
            return self.first
        elif i == 1:
            return self.second
        else:
            raise IndexError("Index must be either 0 or 1 for pairs.")

    def __setitem__(self, i, value):
        if i == 0:
            self.first = value
        elif i == 1:
            self.second = value
        else:
            raise IndexError("Index must be either 0 or 1 for pairs.")

    def __iter__(self):
        yield self.first
        yield self.second

class PairIntInt(_PairIntInt):
    """Wrapper class for C++ standard library pairs of type <integer, integer>.
    Provides tuple interface on the Python level.

    Parameters
    ----------
    new_pair : bool or dict-like
        Boolean on whether to make a new pair or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_pair : bool
        Flag for whether the pointer to the C++ pair should be deallocated
        when the wrapper is dereferenced.
    """
    ## pair somehow needs to be able to reference the base class' first and second members
    ## via super or some other mechanism, and I'm not sure how this should works.. 
    #def __init__(self, first_val = None, second_val = None, bint free_pair=True):
    #    return _PairIntInt.__cinit__(self, first_val, second_val, free_pair)

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "Pair({0}, {1})".format(repr(self.__getitem__(0)), repr(self.__getitem__(1)))



